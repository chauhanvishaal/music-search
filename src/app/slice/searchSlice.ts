import {
  Album,
  Artist,
  SearchResult,
  SearchStatus,
  Song,
} from "../types/index";
import { createAsyncThunk, createSlice, PayloadAction } from "@reduxjs/toolkit";
import { RootState, AppThunk, AppDispatch } from "../store";
import { searchAlbums, searchArtists, searchSongs } from "../services/api";
import { generateSearchSummary } from "../services/searchResults";
import { Entity } from "../types";
import {
  mapAlbumResponse,
  mapArtistResponse,
  mapSongResponse,
} from "../services/responseMapper";

export interface SearchState {
  searchTerm: string;
  searchEntity: Entity;
  results: Array<Artist> | Array<Album> | Array<Song>;
  summary: String;
  status: SearchStatus;
}

const initialState: SearchState = {
  searchTerm: "",
  searchEntity: Entity.Song,
  results: [],
  summary: "",
  status: SearchStatus.Idle,
};


// The function below is called a thunk and allows us to perform async logic. It
// can be dispatched like a regular action: `dispatch(incrementAsync(10))`. This
// will call the thunk with the `dispatch` function as the first argument. Async
// code can then be executed and other actions can be dispatched. Thunks are
// typically used to make async requests.
export const searchAsync = createAsyncThunk<
  SearchResult,
  string,
  {
    dispatch: AppDispatch;
    state: RootState;
    extra: {};
  }
>("search/entity", async (searchTerm, thunkApi) => {
  thunkApi.dispatch(setSearchTerm(searchTerm));
  const searchEntity = thunkApi.getState().search.searchEntity;
  const response = await (searchEntity === Entity.Song
    ? searchSongs(searchTerm)
    : searchEntity === Entity.Artist
    ? searchArtists(searchTerm)
    : searchAlbums(searchTerm));

  const mappedDataObject =
    searchEntity === Entity.Song
      ? mapSongResponse(response.data.results)
      : searchEntity === Entity.Artist
      ? mapArtistResponse(response.data.results)
      : mapAlbumResponse(response.data.results);

  // The value we return becomes the `fulfilled` action payload
  return {
    resultCount: response.data.resultCount,
    results: [...mappedDataObject],
  };
});


export const searchSlice = createSlice({
  name: "search",
  initialState,
  reducers: {
    setSearchTerm: (state, action: PayloadAction<string>) => {
      state.searchTerm = action.payload;
    },
    _setSearchEntity: (state, action: PayloadAction<Entity>) => {
        // mutating syntax alright cause of Immer library. Saves you from destructuring syntax
      state.searchEntity = action.payload;
    },
  },
  // The `extraReducers` field lets the slice handle actions defined elsewhere,
  // including actions generated by createAsyncThunk or in other slices.
  extraReducers: (builder) => {
    builder
      .addCase(searchAsync.pending, (state) => {
        state.status = SearchStatus.Loading;
      })
      .addCase(searchAsync.fulfilled, (state, action) => {
        state.status = SearchStatus.Idle;
        state.summary = generateSearchSummary(action.payload.resultCount);
        state.results = action.payload.results;
      });
  },
});

export const setSearchEntity = (entity: Entity): AppThunk => (dispatch, getState) => {
    dispatch(_setSearchEntity(entity));
    const searchTerm = getState().search.searchTerm;
    searchTerm && dispatch(searchAsync(searchTerm) as any)
}

const { _setSearchEntity } = searchSlice.actions;
export const { setSearchTerm } = searchSlice.actions;

// SELECTORS
export const selectSearchTerm = (state: RootState) => state.search.searchTerm;
export const selectResults = (state: RootState) => state.search.results;
export const selectResultSummary = (state: RootState) => state.search.summary;
export const selectSearchEntity = (state: RootState) =>
  state.search.searchEntity;

export default searchSlice.reducer;
